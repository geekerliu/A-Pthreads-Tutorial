# 前戏

所有的Unix类系统都是多任务操作系统。unix允许一个用户同时运行多个进程，
这是我们今天使用的最强大、最灵活的多任务编程模型之一。

在传统的unix模式，进程都是通过fork()系统调用创建的。

Fork()产生一个当前进程的拷贝。在子进程中fork()返回1，
在父进程中fork返回子进程的pid。fork()通常使用方法：

```
[do parent stuff]
ppid = fork ();
if (ppid < 0) {
        fork_error_function ();
} else if (ppid == 1) {
        child_function ();
} else {
        parent_function ();
}
```

注意fork在两个完全独立的进程返回。每个进程都有自己的地址空间，
有它们自己的变量（除了一些特别的SysV IPC变量共用，但这是很特殊的情况）。
这种独立性，提供了内存保护也更稳定，但是这导致的问题是，
当你想让多个进程处理同一个任务/问题的时候。是的，
你可以使用pipes或者SysV IPC在进程间通信,但是还是有一些其它的问题。

* 在进程间切换的代价很高
* 进程调度器可以处理的进程数目有严重的限制
* 用于进程间同步的变量很慢

由于这些原因，或者其它某些原因，线程(轻量的进程)就非常有用了。
线程之间分享相同的地址空间，它们是在进程内部调度，因此避免了进程间的低效问题。

一个非常受欢迎的创建多线程的API是`pthreads`，
又以POSIX threads著称P1003.1c, or ISO/IEC 9945-1:1990c.这个API就是今天教程的主题。